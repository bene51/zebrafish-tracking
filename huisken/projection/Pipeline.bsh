import huisken.projection.*;
import huisken.util.*;
import huisken.jocl.examples.JOCL_HistogramFeatures;
import mpicbg.imglib.image.Image;
import mpicbg.imglib.image.ImagePlusAdapter;
import mpicbg.imglib.image.display.imagej.ImageJFunctions;
import vib.NaiveResampler;
import vib.FastMatrix;
import vib.InterpolatedImage;

public void print(float[] f) {
	for(float v : f)
		System.out.print(v + " ");
	System.out.println();
}

public float[] mul(float[] f, float r) {
	for(int i = 0; i < f.length; i++)
		f[i] *= r;
	return f;
}

/*

// opening the images
path1 = "/Users/huiskenlab/Documents/SPIMdata/Bene/timelapse_for_sphere_projection/110405_JH_sox17/recording_003_e0000/file_s000_a090_e0000_i1_p/Tifs";
path2 = "/Users/huiskenlab/Documents/SPIMdata/Bene/timelapse_for_sphere_projection/110405_JH_sox17/recording_003_e0000/file_s001_a270_e0001_i1_p/Tifs";

pw = 1.14286;
ph = 1.14286;
pd = 4.0;

imp1 = FolderOpener.open(path1);
imp1.getCalibration().pixelWidth  = pw;
imp1.getCalibration().pixelHeight = ph;
imp1.getCalibration().pixelDepth  = pd;
ConvertTo8.convert(imp1, 0.001f);

imp2 = FolderOpener.open(path2);
imp2.getCalibration().pixelWidth  = pw;
imp2.getCalibration().pixelHeight = ph;
imp2.getCalibration().pixelDepth  = pd;
ConvertTo8.convert(imp2, 0.001f);


cx = imp2.getWidth()     * pw / 2;
cy = imp2.getHeight()    * ph / 2;
cz = imp2.getStackSize() * pd / 2;

c1 = new InterpolatedImage(imp1).getCenterOfGravity();
c2 = new InterpolatedImage(imp2).getCenterOfGravity();

print(c1);
print(c2);

// step1: rigid registration
matrix = FastMatrix.translate(cx, cy, cz).times(new FastMatrix(new double[][] {
	{-1, 0,  0, 0},
	{ 0, 1,  0, 0},
	{ 0, 0, -1, 0}})).times(FastMatrix.translate(-cx, -cy, -cz));
matrix.apply(c2);
matrix = FastMatrix.translate(-c2.x + c1.x, -c2.y + c1.y, -c2.z + c1.z).times(matrix);

	
System.out.println(matrix);
rr = new FastRigidRegistration();
rr.rigidRegistration(
		imp1,      // template
		imp2,      // model
		matrix,    // initial transform,
		6,         // startlevel
		3,         // stoplevel
		1.0);      // tolerance
matrix = rr.getMatrix();
aligned = rr.getTransformed(imp1, imp2, matrix);
imp1.show();
aligned.show();

print(matrix);


imp1 = NaiveResampler.resample(imp1, 4, 4, 1);
imp2 = NaiveResampler.resample(imp2, 4, 4, 1);
*/

// TODO histogram equalization
imp1 = IJ.openImage("/Users/huiskenlab/Documents/SPIMdata/Bene/timelapse_for_sphere_projection/110405_JH_sox17/recording_003_e0000/a090.tif");
imp2 = IJ.openImage("/Users/huiskenlab/Documents/SPIMdata/Bene/timelapse_for_sphere_projection/110405_JH_sox17/recording_003_e0000/a270.tif");
matrix = new vib.FastMatrix(new double[][] {
	{ -0.9996977586314797,   0.018862026762183765, -0.015767540506322224, 1115.521487281513   },
	{  0.016275124522697998, 0.988464260446057,     0.1505773095210576,    -58.41149858961279 },
	{  0.01842584350759886,  0.15027518014380276,  -0.9884724874895513,    651.2726027623837  }});


new StackConverter(imp1).convertToGray32();
new StackConverter(imp2).convertToGray32();

img1 = ImagePlusAdapter.wrap(imp1);
img2 = ImagePlusAdapter.wrap(imp2);


img1s = new Image[] {img1, null, null};
img2s = new Image[] {img2, null, null};
grad1s = new Image[3];
grad2s = new Image[3];

print(img1s[0].getCalibration());
print(img2s[0].getCalibration());
for(int i = 1; i < 3; i++) {
	img1s[i] = FuseImages.downsample(img1s[i - 1]); // TODO check calibration
	img2s[i] = FuseImages.downsample(img2s[i - 1]);
	img1s[i].setCalibration(mul(img1s[i - 1].getCalibration(), 2.0f));
	img2s[i].setCalibration(mul(img2s[i - 1].getCalibration(), 2.0f));
	print(img1s[i].getCalibration());
	print(img2s[i].getCalibration());
}

ImagePlus org1, org2;
for(int i = 0; i < 3; i++) {
	print("i = " + i);

	print("Calculating gradients");
	grad1s[i] = img1s[i]; // FuseImages.calculateGradient(img1s[i]);
	grad2s[i] = img2s[i]; // FuseImages.calculateGradient(img2s[i]);

	print("Normalizing");
	FuseImages.normalize(grad1s[i]);
	FuseImages.normalize(grad2s[i]);

	print("Transforming the model image");
	grad2s[i] = FuseImages.transformImage(grad1s[i], grad2s[i], matrix);

	if(i == 0) {
		org1 = ImageJFunctions.copyToImagePlus(grad1s[0]);
		org2 = ImageJFunctions.copyToImagePlus(grad2s[0]);
		ConvertTo8.convert(org1, 0);
		ConvertTo8.convert(org2, 0);
	}

	print("Filtering");
	//grad1s[i] = ImagePlusAdapter.wrap(JOCL_HistogramFeatures.doit(ImageJFunctions.copyToImagePlus(grad1s[i]), JOCL_HistogramFeatures.RANGE));
	//grad2s[i] = ImagePlusAdapter.wrap(JOCL_HistogramFeatures.doit(ImageJFunctions.copyToImagePlus(grad2s[i]), JOCL_HistogramFeatures.RANGE));
	ImageJFunctions.copyToImagePlus(grad1s[i]).show();
	grad1s[i] = FuseImages.filter(grad1s[i], 5);
	grad2s[i] = FuseImages.filter(grad2s[i], 5);

}


grad1s[1] = FuseImages.upsample(grad1s[1]); // TODO check calibration
grad1s[2] = FuseImages.upsample(grad1s[2]);
grad1s[2] = FuseImages.upsample(grad1s[2]);

grad2s[1] = FuseImages.upsample(grad2s[1]); // TODO check calibration
grad2s[2] = FuseImages.upsample(grad2s[2]);
grad2s[2] = FuseImages.upsample(grad2s[2]);

FuseImages.add(grad1s[0], grad1s[1]);
FuseImages.add(grad1s[0], grad1s[2]);

FuseImages.add(grad2s[0], grad2s[1]);
FuseImages.add(grad2s[0], grad2s[2]);

grad1s[0].setName("result image 1");
grad2s[0].setName("result image 2");

imp1 = ImageJFunctions.copyToImagePlus( grad1s[0] );
imp2 = ImageJFunctions.copyToImagePlus( grad2s[0] );
ConvertTo8.convert(imp1, 0.001f);
ConvertTo8.convert(imp2, 0.001f);
imp1.show();
imp2.show();

IJ.run("Merge Channels...", "red=[result image 1] green=[result image 2] blue=*None* gray=*None* keep");
merge = IJ.getImage();

w = imp1.getWidth();
h = imp1.getHeight();
d = imp1.getStackSize();
result = IJ.createImage("result", "rgb black", 5 * w, h, d);

for(int z = 0; z < d; z++) {
	rip = result.getStack().getProcessor(z + 1);
	
	ip = org1.getStack().getProcessor(z + 1).convertToRGB();
	rip.copyBits(ip, 0, 0, Blitter.ADD);
	
	ip = org2.getStack().getProcessor(z + 1).convertToRGB();
	rip.copyBits(ip, 1 * w, 0, Blitter.ADD);
	
	ip = imp1.getStack().getProcessor(z + 1).convertToRGB();
	rip.copyBits(ip, 2 * w, 0, Blitter.ADD);
	
	ip = imp2.getStack().getProcessor(z + 1).convertToRGB();
	rip.copyBits(ip, 3 * w, 0, Blitter.ADD);
	
	ip = merge.getStack().getProcessor(z + 1).convertToRGB();
	rip.copyBits(ip, 4 * w, 0, Blitter.ADD);
}
result.show();


