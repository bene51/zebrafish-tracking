import huisken.projection.*;
import ij.ImagePlus;
import ij.plugin.FolderOpener;
import ij.process.FloatProcessor;
import ij.process.StackConverter;
import ij.process.ImageConverter;
import vib.NaiveResampler;
import javax.vecmath.Point3f;
import javax.vecmath.Color3f;

import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;

import ij3d.Image3DUniverse;

import meshtools.IndexedTriangleMesh;

import customnode.CustomTriangleMesh;


path = "/Users/huiskenlab/Documents/SPIMdata/Bene/timelapse_for_sphere_projection/110405_JH_sox17/recording_003_e0000/file_s001_a270_e0001_i1_p/Tifs";
// 8/7 x 8/7 x 4 or 1.14286 x 1.14286 x 4
// path = "/home/bene/PostDoc/projection/s02_i0.tif";
IJ.showStatus("Fitting sphere");
t = System.currentTimeMillis();
image = IJ.openImage(path);
image = FolderOpener.open(path);
image.getCalibration().pixelWidth = 1.14286;
image.getCalibration().pixelHeight = 1.14286;
image.getCalibration().pixelDepth = 4;
image.show();
print("Needed " + (System.currentTimeMillis() - t) + " ms for loading the image");
print("============");

image = IJ.getImage();
IJ.showStatus("Fitting sphere");
t = System.currentTimeMillis();
threshold = 2050;
fs = new huisken.projection.Fit_Sphere(image);
print("begin fit");
fs.fit(threshold);
print("end fit");
center = new Point3f();
fs.getCenter(center);
radius = fs.getRadius();
print(radius);
print("Needed " + (System.currentTimeMillis() - t) + " ms for fitting a circle");
print("============");

// IJ.showStatus("Resampling");
// t = System.currentTimeMillis();
// ImageConverter.setDoScaling(true);
// new StackConverter(image).convertToGray8();
// image = NaiveResampler.resample(image, 4);
// image.show();
// print("Needed " + (System.currentTimeMillis() - t) + " ms for the downsampling");
// print("============");


IJ.showStatus("Calculating sphere vertices");
t = System.currentTimeMillis();
smp = new SphericalMaxProjection(image, center, (float)radius);
print("Created sphere with " + smp.getSphere().nVertices + " vertices");
print("Needed " + (System.currentTimeMillis() - t) + " ms to init projection");
print("============");



IJ.showStatus("Project image");
t = System.currentTimeMillis();
smp.project(image);
print("Needed " + (System.currentTimeMillis() - t) + " ms for the projection");
print("============");


/*
IJ.showStatus("Create 3D view");
t = System.currentTimeMillis();
IndexedTriangleMesh sphere = smp.getSphere();

float[] maxima = smp.getMaxima();
HashMap vertexToColor = new HashMap();
for(int i = 0; i < maxima.length; i++)
	vertexToColor.put(sphere.getVertices()[i], maxima[i]);

List triangles = sphere.createMesh();
List colors = new ArrayList();
for(Point3f v : triangles) {
	float col = vertexToColor.get(v) / 255f;
	colors.add(new Color3f(col, col, col));
}

CustomTriangleMesh ctm = new CustomTriangleMesh(triangles);
ctm.setColor(colors);

Image3DUniverse univ = new Image3DUniverse();
univ.show();
univ.addCustomMesh(ctm, "projection");
print("Needed " + (System.currentTimeMillis() - t) + " ms for the 3D view");
print("============");

*/

/*
IJ.showStatus("Create mercator map");
t = System.currentTimeMillis();
smp.createMercatorProjection(1440).show();
IJ.showStatus("");
print("Needed " + (System.currentTimeMillis() - t) + " ms for the mercator projection");
print("============");
*/

